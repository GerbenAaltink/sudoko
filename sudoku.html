<html>
	<head>
	</head>
	<body>

		<div id="app" class="app"></div>
		<pre>
			TODO:
			 - if orange fields, no other selections should be possible than deselect.
		</pre>
		<template id="template_sudoku_container">
			<div class="width:640px;height:640px;text-size:26px;" class="container-content"></div>
		</template>
		<template id="template_sudoku_cell">
			<div class="cell-content"></div>
		</template>
		<style type="text/css">
			.app {
				width:400px;
				height:400px;
			}
			.cell-content {
				    user-select: none; /* Standard syntax */
				    -webkit-user-select: none; /* Safari */
				    -moz-user-select: none; /* Firefox */
				    -ms-user-select: none; /* Internet Explorer/Edge */
			border:1px solid #CCCCCC;line-height:250%;text-align:center;height:10%;width:10%;float:left;
			}
			.sudoku-cell-selected {
				background-color: lightgreen;
			}
			.sudoku-cell-invalid{
				color: red;
				font-weight: bold;
			}	
		</style>
		<script type="text/javascript">
			const game_size = 9;
			const container_template = document.getElementById('template_sudoku_container');
			const cell_template = document.getElementById("template_sudoku_cell");
			const app = document.getElementById('app'); //.importNode(container_template.content, true);
			const _hashChars = "abcdefghijklmnopqrstuvwxyz\"':[]0123456789";
			function hashString(str) {
				let result = 0;
				for(let i = 0; i < str.length; i++){
					result += (_hashChars.indexOf(str[i]) + 1) * (i * 40);
				}
				return result;
			}
			class State {
				number = 0
				cells = []
				selection = []
				selectionCount = 0
				_string = null
				_hash = null
				constructor(number){
					this.number = number;
				}
				getHash(){
					if(this._hash == null){
						let started = false;
						let count = 0;
						let hash = this.cells.filter((cell)=>{
							if(!started && cell.state[0] == 0 && cell.state[1] == 1)
								return false;
							started = true;;
							count++;
							return true;
						}).map(cell=>{
							return cell.state;
						}).join('');
						this._hash = `${count}${hash}`;
					}
					return this._hash
				}
				equals(otherState){
					if(otherState.selectionCount != this.selectionCount)
						return false;
					return otherState.getHash() == this.getHash();
				}
				toString()
				{
					if(this._string == null){
						this._string = JSON.stringify({
						number:this.number,
						selection:this.selection.map(cell=>cell.toString()),
						cells:this.cells
					});
					}
					return this._string
				}
			};
			class Cell {
				row = 0;
				col = 0;
				letter = null
				name = null
				options = [];
				value = 0;
				values = []
				element = null;
				app = null;
				selected = false;
				container = null;
				valid = true;
				getState() {
					return `${this.selected?1:0}${this.valid?1:0}`;
				}
				toggleSelect(){
					this.selected = !this.selected;
					
					if(this.selected){
						this.select();
						//this.element.classList.add('sudoku-cell-selected');
					}else{
						this.deSelect();
						//this.element.classList.remove('sudoku-cell-selected');
					}
					this.update();
					return this.selected;
				

				}
				addNumber(number){
					this.values.pop(number);
					this.values.push(number);
					this.value = Number(number);
					this.validate();
					//this.update();
					this.element.textContent = this.number == 0 ? "" :  String(number);
				}
				onClick(){
					//this.
					this.toggleSelect();
					//this.app.onCellClick(this)
				}
				deSelect(){
					this.selected = false;
					this.element.classList.remove('sudoku-cell-selected');
				}
				select(){
					this.selected = true;
					this.element.classList.add('sudoku-cell-selected');

				}
				isValid(){
					const _this = this;
					this.valid = !this.value || !this.app.cells.filter(cell=>{
						return cell.value != 0 && 
							cell != _this && 
							(cell.row == _this.row || cell.col == _this.col) && 
							cell.value == _this.value;
					}).length;
					return this.valid;
				}
				update(){
					if(this.selected)
						this.select()
					else
						this.deSelect()
					this.app.cells.forEach(cell=>{
						cell.validate()
					})
					this.element.textContent = this.value ? String(this.value) : "";
					
				}
				validate(){
					if(this.isValid()){
						this.element.classList.remove('sudoku-cell-invalid');
					}else{
						this.element.classList.add('sudoku-cell-invalid');
					}
					return this.valid;
				}
				constructor(app,row,col){
					this.app = app;
					this.container = document.importNode(cell_template.content,true);
					this.row = row;
					this.col = col;
					this.selected = false;
					this.letter = "abcdefghi"[row];
					this.name = `${this.letter}${this.col}`
					this.value = 0;
					this.values = [];
					this.element = this.container.querySelector('.cell-content');
					this.valid = true;
					const _this = this;
					this.element.addEventListener('click',(e)=>{
						_this.onClick();
					});
					
					this.element.addEventListener('mousemove', (e)=>{
						


						if(e.buttons == 1)
							_this.select();
						else if(e.buttons == 2)
							_this.deSelect();
						else
							_this.app.pushState()

					});
					this.element.addEventListener('mouseexit', (e)=>{
						if(!e.buttons){
					//		_this.app.pushState();
						}
					});
					this.element.addEventListener('contextmenu',(e)=>{
						e.preventDefault();
						if(_this.selected){
						_this.deSelect();
						}else{
							_this.app.deSelectAll();
						}
					});
				}
				render(container){
					container.appendChild(this.container);
				}
				toString(){
					return `${this.row}:${this.col}`
				}
			}
			class Sudoku {
				cells = [];
				game_size = 0;
				cell_count = 0;
				selectedCells = []
				container = null
				element = null
				states = []
				previousSelection = []
				state_number = 1
				constructor(container,game_size){
					
					const _this = this;
					this.container = container
					this.element = container
					this.game_size = game_size;
					this.cell_count = game_size * game_size;
					for(let row = 0; row < this.game_size; row++){
						for(let col = 0; col < this.game_size; col++){
							this.cells.push(new Cell(this,row,col));
						}
					}

					document.addEventListener('keypress',(e)=>{
						if(!isNaN(e.key) || e.key == 'd'){
							let number = e.key == 'd' ? 0 : Number(e.key);
							_this.addNumberToSelection(number);
							//console.info({set:Number(e.key)});
						}
						if(e.key == 'u'){
							_this.popState();
						}
						if(e.key == 'r'){
							if(this.selection().length){
								this.pushState();
							_this.deSelectAll();
							}else{
								let state = this.getLastState();
								if(state){
									state.cells.filter(cell=>cell.selected).forEach(cell=>{
										
										this.getCellByName(cell.name).select();
									})
								}
							}
						}
					});
					this.element.addEventListener('mousemove',(e)=>{
						//this.pushState();
					})
					document.addEventListener('dblclick',(e)=>{
						_this.previousSelection = _this.selection();
						_this.cells.forEach(cell=>{
							cell.deSelect();
						});
					});
					document.addEventListener('contextmenu',(e)=>{
					
					});
					this.element.addEventListener('mouseexit', (e)=>{
						// Edge case while holding mouse button while dragging out. Should save state
							_this.pushState();
					});
					this.element.addEventListener('mouseup', (e)=>{
						_this.pushState();
					});
					this.pushState()	
				
				}
				isValid(){
					return this.cells.filter(cell=>!cell.isValid()).length == 0
				}
				createState(){
					const state = new State(this.state_number)
					let selectedCount = 0;
					state.cells = this.cells.map(cell=>{
						if(cell.selected){
							selectedCount++;
						}
						return {name:cell.name,values:cell.values,value:cell.value,selected:cell.selected,state:cell.getState()}
					
					});
					state.selectedCount = selectedCount;
					return state;
				}
				pushState() {
					const state = this.createState();
					const previousState = this.getLastState();
					if(!previousState || !previousState.equals(state)){	
						this.states.push(state);
						this.state_number++;
						console.info({pushState:state.getHash(),length:state.getHash().length,number:state.number});
					}
				}
				getLastState(){
					return this.states.length ? this.states.at(this.states.length - 1) : null; 
				}
				popState(){
					let state = this.states.pop();
					
					if(!state)
						return;
					if(state.equals(this.createState())){
						return this.popState();
					}
					state.cells.forEach(stateCell=>{
						const cell = this.getCellByName(stateCell.name);
						cell.selected = stateCell.selected;
						cell.values = stateCell.values;
						cell.value = stateCell.value;
						cell.update();
					})
					console.info({popState:state.getHash(),length:state.getHash().length,number:state.number});
				}
				getCellByName(name){
					return this.cells.filter(cell=>{
						return cell.name == name
					})[0]
				}
				deSelectAll(){
					this.cells.forEach(cell=>{
						cell.deSelect();
					});
				}
				selection() {
					return this.cells.filter(cell=>{
						return cell.selected
					});
				}
				onSelectionToggle() {
					
				}
				addNumberToSelection(number){
					const _this = this;
					this.pushState();
					this.selection().forEach((cell)=>{
						


						cell.addNumber(number)
					        cell.update();	

					})
					_this.pushState();
					if(this.isValid()){
						this.deSelectAll();
					}
					_this.pushState();	
				}
				onCellDblClick(cell){
					this.previousSelection = this.selection();
					this.popState()
					let originalSelected = this.selctedCells
					if(cell.selected){
						this.selectedCells.push(cell);
					}else{
						this.selectedCells.pop(cell);
					}
					if(!this.originalSelected != this.selectedCells)
					{
						this.popState();
					}
					//console.info({selected:this.selectedCells});
				}
				render(){
					for(let i = 0; i < this.cell_count; i++){
						this.cells[i].render(this.element);
					}
				}
			}
			const sudoku = new Sudoku(app,9);
			sudoku.render();/*
			document.addEventListener('contextmenu',(e)=>{
				e.preventDefault();
			});*/
			/*
			for(let i = 0; i < game_size*game_size; i++){
				const cell = document.importNode(cell_template.content,true);

				app.appendChild(cell);	
			}*/
			//document.body.appendChild(app);
		</script>
	</body>
